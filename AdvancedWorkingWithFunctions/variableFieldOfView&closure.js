/**
 * Замыкание — это функция,
 * которая "помнит" своё лексическое окружение даже после того,
 * как внешняя функция завершила выполнение.
 */

// 🧠 Пример замыкания
// function makeCounter() {
//     let count = 0;
//     return function() {
//         return ++count;
//     };
// }

// const counter = makeCounter();
// console.log(counter()); // 1
// console.log(counter()); // 2

/**
 * Здесь:
 * makeCounter — внешняя функция, создающая переменную count.
 * Внутри неё возвращается анонимная функция, которая увеличивает count на 1 и возвращает его.
 * При каждом вызове counter() возвращается новое значение count, даже несмотря на то, что внешняя функция уже завершила выполнение.
 * Это и есть замыкание: внутренняя функция сохраняет доступ к переменной count, даже после завершения работы внешней функции.
 */

// 🧩 Почему это важно?

/**
 * Замыкания позволяют:
 *
 * Инкапсулировать состояние: скрывать внутренние детали реализации и предоставлять только необходимые методы.
 * Создавать функции с сохранённым состоянием: например, счётчики, таймеры, обработчики событий.
 * Эмулировать приватные переменные: скрывать данные от внешнего мира, предоставляя доступ только через публичные методы.
 */

// ⚠️ Важные моменты

/**
 * Доступ к переменным: функция замыкания всегда будет использовать актуальное значение переменной,
 * доступное в момент её вызова, а не в момент её создания.
 */

// let name = "John";

// function sayHi() {
//     alert("Hi, " + name);
// }

// name = "Pete";
// sayHi(); // Hi, Pete

// 🛠️ Практическое применение

/**
 * Замыкания позволяют создавать модули, скрывая внутренние детали реализации и предоставляя только публичный интерфейс.
 */

// const counterModule = (function() {
//     let count = 0;
//     return {
//         increment: function() {
//             count++;
//             return count;
//         },
//         decrement: function() {
//             count--;
//             return count;
//         },
//         getCount: function() {
//             return count;
//         }
//     };
// })();
//
// console.log(counterModule.increment()); // 1
// console.log(counterModule.getCount()); // 1

// Функции с сохранённым состоянием
// function makeAdder(x) {
//     return function(y) {
//         return x + y;
//     };
// }

// const add5 = makeAdder(5);
// console.log(add5(2)); // 7

// 🚮 Сборка мусора и замыкания

/**
 * Когда создаётся замыкание, внутренняя функция сохраняет ссылку на переменные из внешней функции,
 * и пока эта внутренняя функция доступна (то есть на неё есть хотя бы одна ссылка),
 * вся эта область памяти остаётся в живых.
 */

// function outer() {
//     let data = 'важные данные';
//     return function inner() {
//         console.log(data);
//     };
// }

// const closure = outer(); // closure — ссылка на inner, она сохраняет доступ к data
// Пока closure существует, data не удалится из памяти

// closure(); // выводит: важные данные

// Если сделать closure = null, то ссылка пропадёт, и data тоже очистится

//====================================================================================================================//
/**
 * Tasks
 */
//--------------------------------------------------------------------------------------------------------------------//
// Сумма с помощью замыканий

/**
 * Напишите функцию sum, которая работает таким образом: sum(a)(b) = a+b.
 * Да, именно таким образом, используя двойные круглые скобки (не опечатка).
 */

// const sum = a => {
//     return (b) => {
//         return a + b;
//     }
// };
// console.log(sum(1)(2)); // 3
// console.log(sum(5)(-1)); // 4

/**
 * Not solved
 */
//====================================================================================================================//
// Фильтрация с помощью функции

/**
 * У нас есть встроенный метод arr.filter(f) для массивов. Он фильтрует все элементы с помощью функции f.
 * Если она возвращает true, то элемент добавится в возвращаемый массив.
 *
 * Сделайте набор «готовых к употреблению» фильтров:
 *
 * inBetween(a, b) – между a и b (включительно).
 * inArray([...]) – находится в данном массиве.
 * Они должны использоваться таким образом:
 *
 * arr.filter(inBetween(3,6)) – выбирает только значения между 3 и 6 (включительно).
 * arr.filter(inArray([1,2,3])) – выбирает только элементы, совпадающие с одним из элементов массива
 */

// const arr = [ 1, 2, 3, 4, 5, 6, 7 ];
// const inBetween = (a, b) => {
//     return (num) => {
//         return num >= a && num <= b;
//     };
// };
// console.log(arr.filter(inBetween(3, 6))); // 3,4,5,6

// const arr = [ 1, 2, 3, 4, 5, 6, 7 ];
// const inArray = array => {
//     return (num) => {
//         return array.includes(num);
//     };
// };
// console.log( arr.filter(inArray([1, 2, 10])) ); // 1,2

//====================================================================================================================//
// Сортировать по полю

// const users = [
//     { name: "Иван", age: 20, surname: "Иванов" },
//     { name: "Пётр", age: 18, surname: "Петров" },
//     { name: "Анна", age: 19, surname: "Каренина" }
// ];

// const byField = fieldName => {
//     return (a, b) => a[fieldName] > b[fieldName] ? 1 : -1;
// };
// console.log(users.sort(byField('name')));
// console.log(users.sort(byField('age')));

//====================================================================================================================//

